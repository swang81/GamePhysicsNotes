<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Game Physics &amp; Development Notes</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-c6ad1d1d.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-2960637e.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Game Physics &amp; Development Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="game-physics-and-development-notes"><a class="header" href="#game-physics-and-development-notes">Game Physics and Development Notes</a></h1>
<p>作者：小杰克<br>个人主页：<a href="https://swang81.github.io/">https://swang81.github.io/</a></p>
<ul>
<li>
<p>📘 在线阅读（GitHub Pages）：<br><a href="https://swang81.github.io/GamePhysicsNotes/">GamePhysicsNotes</a></p>
</li>
<li>
<p>💻 GitHub 仓库：<br><a href="https://github.com/swang81/GamePhysicsNotes">swang81/GamePhysicsNotes</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="游戏物理专题"><a href="#游戏物理专题" class="header">游戏物理专题</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="数学物理基础"><a href="#数学物理基础" class="header">数学物理基础</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="碰撞检测"><a href="#碰撞检测" class="header">碰撞检测</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="动力学与约束求解"><a href="#动力学与约束求解" class="header">动力学与约束求解</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="高级物理模拟"><a href="#高级物理模拟" class="header">高级物理模拟</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="物理可视化与调试"><a href="#物理可视化与调试" class="header">物理可视化与调试</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="游戏开发"><a href="#游戏开发" class="header">游戏开发</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="混合现实mr游戏开发入门"><a class="header" href="#混合现实mr游戏开发入门">混合现实（MR）游戏开发入门</a></h1>
<p>近年来，虚拟现实（VR）、增强现实（AR）和混合现实（MR）技术的迅速崛起，推动了游戏开发进入全新的维度。作为一名VR/MR游戏开发者，我亲眼见证了技术的不断进步与升级。从微软第一代HoloLens头显到HTC Vive，再到Quest、Quest 2，直到如今为Meta Quest 3开发游戏，我深刻感受到了这些技术如何颠覆传统2D和3D视觉表现，并重新定义了游戏的交互方式和沉浸感体验。</p>
<p>许多朋友常常问我：“VR、AR和MR有何区别？”、“购买哪个头显最合适？”、“有哪些好玩的VR、MR游戏？”为了解答这些问题，我决定写这篇文章，探讨这三种技术的核心特点及其在游戏中的应用，介绍主流游戏设备，并为开发者梳理Meta Quest 3的Unity开发路线。</p>
<h2 id="vr游戏沉浸式虚拟体验"><a class="header" href="#vr游戏沉浸式虚拟体验">VR游戏：沉浸式虚拟体验</a></h2>
<p>VR（虚拟现实）游戏让玩家通过头戴显示设备（HMD）完全沉浸在虚拟环境中。通过视觉、听觉以及手柄的振动反馈，VR游戏为玩家提供了高度的沉浸感。</p>
<p>推荐一款科幻风的VR游戏——《红色物质2》（Red Matter 2）。这款屡获殊荣的沉浸式解谜冒险游戏，让玩家扮演特工Sasha，在月球基地揭开神秘的“红物质”背后的秘密。游戏使用优化后的Unreal Engine进行渲染，营造了一个科幻的环境，带来极具沉浸感的游戏体验。</p>
<p><img src="gameDevelopment/MR_game_development/images/redMatter.jpg" alt="RedMatter"></p>
<h2 id="ar游戏现实与虚拟的融合"><a class="header" href="#ar游戏现实与虚拟的融合">AR游戏：现实与虚拟的融合</a></h2>
<p>与VR游戏不同，AR游戏通过智能手机、AR眼镜或平板电脑等设备，通过设备上的摄像头捕捉现实世界图像，并将虚拟物体叠加到这些现实图像中，从而为玩家呈现现实与虚拟融合的场景。</p>
<p>推荐一款AR手机游戏——《宇宙战线 AR》。在这款游戏中，玩家将化身为宇宙舰队指挥官，指挥自己的舰队在浩瀚的宇宙中与敌人展开激烈战斗。游戏利用AR技术将虚拟战舰与现实环境结合，你在家中的客厅可以指挥舰队与敌舰、激光炮火展开战斗。</p>
<h2 id="mr游戏虚拟与现实的深度交互"><a class="header" href="#mr游戏虚拟与现实的深度交互">MR游戏：虚拟与现实的深度交互</a></h2>
<p>MR（混合现实）游戏将VR和AR的特点结合，提供更为自然的交互体验。玩家佩戴MR头显后，不仅能看到虚拟元素，还能与真实世界进行深度互动。MR设备通过理解周围环境，实现虚拟元素与现实物体的实时交互。</p>
<p>推荐最新发行的MR游戏—《空间特工队》（Spatial Ops）。这款游戏被誉为MR模式下的FPS游戏，提供单人战役模式与竞技场模式。在单人模式中，玩家扮演一名特工，在激烈的射击战斗中保护现实世界；而竞技场模式则让玩家将家中的空间瞬间转变为战场，体验科幻版的CS。</p>
<p><img src="gameDevelopment/MR_game_development/images/spatialOps.jpg" alt="SpatialOps"></p>
<h2 id="设备推荐主流硬件分析"><a class="header" href="#设备推荐主流硬件分析">设备推荐：主流硬件分析</a></h2>
<p>在VR、AR和MR技术中，目前VR和MR游戏应用最为广泛。以下是一些主要硬件设备的介绍：</p>
<p><strong>Meta Quest系列</strong>：由Facebook推出，是全球销量领先的头显设备。以Quest 3为例，这款设备搭载了骁龙XR2 Gen 2处理器，单眼分辨率高达2064×2208，刷新率可达到90Hz，售价大约在3000-4000元之间，是同价位中性能表现最优的选择。游戏需要通过Meta商店购买，由于网络原因，在国内使用时需要借助加速器。适合对硬件配置和系统设置有一定了解的用户。</p>
<p><strong>Pico系列</strong>：作为国内VR/MR市场的领先品牌，Pico系列在2024年推出了与Quest 3竞争的Pico 4 Ultra。这款设备同样搭载骁龙XR2 Gen 2处理器，功能与Quest 3类似，尽管平台上的游戏数量不及Meta多，但在国内使用时无需加速器，适合更广泛的用户群体。</p>
<p><strong>Vision Pro</strong>：苹果公司于2024年推出的Vision Pro是高端MR设备的代表，配备M2芯片，单眼分辨率高达3660×3200，是市场上计算能力最强的头显之一。Vision Pro支持沉浸度调节，并可在MR和VR模式之间自由切换。然而，由于该设备未配备手柄，游戏交互主要依赖手势控制。因此，目前适配的游戏多为棋牌类和休闲类游戏。设备售价接近3万元，适合追求极致显示效果的用户。</p>
<h2 id="开发路线从头开始"><a class="header" href="#开发路线从头开始">开发路线：从头开始</a></h2>
<p>对于开发者，以下是从Meta Quest 3+Unity的开发路线，帮助你一步步准备好开发环境。</p>
<ol>
<li>
<p>确定游戏体验方式：首先要确定游戏的体验方式，是完全沉浸式的VR体验，还是混合现实的MR体验。现在很多游戏提供两种模式，供玩家自由切换。</p>
</li>
<li>
<p>选择游戏引擎：目前，Meta Quest平台上的游戏大多数使用Unity开发，约70%-80%是Unity开发的，剩余的20%-30%使用Unreal Engine（UE）或其他引擎。可以根据个人技术背景和需求选择适合的引擎。</p>
</li>
<li>
<p>准备硬件设备和开发者账号：尽管Meta提供了Meta XR Simulator头显模拟器等工具，许多复杂的场景和性能测试仍需真实设备进行验证。建议购买Quest 3并使用Windows系统的PC进行开发。所有Meta Horizon Store上的应用发布者都需要在Meta开发者中心创建开发者账号。</p>
</li>
<li>
<p>安装Meta开发工具：Meta Quest Developer Hub：Meta提供的开发应用，可进行头显设备设置、性能分析、安装游戏软件以及访问学习资源。Meta Quest Link：通过USB-C或WiFi连接头显到Windows电脑，使用Link模式可以在Quest中直接查看Unity或Unreal游戏运行效果，无需重新编译，提高研发效率。</p>
</li>
</ol>
<h2 id="配置unity"><a class="header" href="#配置unity">配置Unity</a></h2>
<p>Unity的配置主要包括以下几个方面：安装Meta的SDK（All-in-One）、修改项目的目标平台、使用Meta Project Setup Tool进行默认参数设置，安装Meta开发模拟器等。基本功能可以通过添加Building Blocks进行快速实现，详细信息可参考相关文档。</p>
<h2 id="学习mr相关模块"><a class="header" href="#学习mr相关模块">学习MR相关模块</a></h2>
<p>如果开发MR游戏，建议阅读官方的《MR设计指南》，了解常见的基本概念。你还需要熟悉以下功能模块：Passthrough、Scene、Spatial Anchors和MRUK工具包。在Meta Quest Developer Hub中，可以查找相关模块的代码示例进行补充学习。</p>
<p>按照上述步骤，你就可以在Unity中开始编写MR应用，逐步实现“Hello World”级别的MR项目。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>希望通过这篇文章，大家能够对VR、AR、MR技术和游戏开发有所了解，并能根据自己的兴趣和需求开发自己喜欢的游戏。从选择合适的设备到配置开发环境，逐步走向开发成功的第一步。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ue-c-相关内容总结"><a class="header" href="#ue-c-相关内容总结">UE C++ 相关内容总结</a></h1>
<h2 id="1作为-ue-程序员为什么都需要掌握-ue-c和蓝图编程"><a class="header" href="#1作为-ue-程序员为什么都需要掌握-ue-c和蓝图编程">1.作为 UE 程序员为什么都需要掌握 UE C++和蓝图编程？</a></h2>
<p>因为二者在引擎中的定位不同，却又相辅相成：</p>
<ul>
<li><strong>C++</strong>: 负责底层基础，适合实现性能关键模块、框架系统，以及扩展引擎功能。</li>
<li><strong>蓝图</strong>：面向上层逻辑，强调快速迭代、关卡交互和玩法组合，方便策划与美术直接参与。</li>
</ul>
<p>只会 C++，灵活性不足，每次修改逻辑都要重新编译，效率低； 只会蓝图，性能和功能有限，无法胜任复杂系统（如多人联机、GAS、定制渲染管线）。所以最佳实践是 C++ 写底层与性能逻辑，蓝图处理上层与关卡逻辑。一句话总结：C++ 打地基，蓝图盖房子；两者结合，才能高效又稳健。</p>
<h2 id="2-ue-c和普通-c的区别"><a class="header" href="#2-ue-c和普通-c的区别">2. UE C++和普通 C++的区别</a></h2>
<p>Unreal Engine（UE）在底层使用 C++ 语言开发，但 UE C++ 并不等同于标准 C++，它有自己的一套扩展体系和开发规范。</p>
<h3 id="21-ue-对象体系uobject-和-actor"><a class="header" href="#21-ue-对象体系uobject-和-actor">2.1 UE 对象体系：UObject 和 Actor</a></h3>
<p>UE 对象由引擎管理生命周期，普通 C++ 对象需要手动管理。</p>
<ul>
<li><strong>普通 C++</strong>：类是普通的类型，继承和生命周期完全由程序员控制。</li>
<li><strong>UE C++</strong>：所有游戏对象大多继承自 UObject 或 AActor。UE 引入<strong>垃圾回收</strong>（Garbage Collection） 管理 UObject 生命周期。内存分配与销毁不建议直接 new/delete，而是通过 UE 自动进行。</li>
</ul>
<pre><code class="language-C++">// 普通 C++
MyClass* Obj = new MyClass();
delete Obj;

// UE C++， 不用手动 delete，GC 会管理
UObject* Obj = NewObject&lt;UMyObject&gt;();
</code></pre>
<h3 id="22-ue-宏与反射系统"><a class="header" href="#22-ue-宏与反射系统">2.2 UE 宏与反射系统</a></h3>
<p>普通 C++ 无法直接支持蓝图编辑器、序列化和 GC，UE C++ 通过宏实现。</p>
<ul>
<li><strong>普通C++</strong>：没有内置的反射，属性、函数都不能在运行时被动态访问。</li>
<li><strong>UE C++</strong>：使用宏 UCLASS, UPROPERTY, UFUNCTION 扩展类、变量、函数。实现运行时类型信息、序列化、蓝图可访问、网络同步等。</li>
</ul>
<pre><code class="language-C++">UCLASS()
class AMyActor : public AActor
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    int32 Health;

    UFUNCTION(BlueprintCallable)
    void TakeDamage(int32 Amount);
};
</code></pre>
<h3 id="23指针与智能指针"><a class="header" href="#23指针与智能指针">2.3指针与智能指针</a></h3>
<p>UE 自带指针体系，兼容 GC 和蓝图系统。</p>
<ul>
<li><strong>普通 C++</strong>：*、&amp;、std::shared_ptr、std::unique_ptr 常用。</li>
<li><strong>UE C++</strong>：强烈依赖 UObject* 指针，由 GC 管理。对非 UObject 类型可以使用 UE 提供的智能指针 TSharedPtr、TWeakPtr、TUniquePtr 专门用于非 UObject 类型的对象管理。新版本引入 TObjectPtr 以增强指针安全性。</li>
</ul>
<h3 id="24编译机制与模块化"><a class="header" href="#24编译机制与模块化">2.4编译机制与模块化</a></h3>
<p>UE 编译器不只是 C++ 编译，还包括宏解析、蓝图接口生成等。</p>
<ul>
<li><strong>普通 C++</strong>：编译器直接处理 .cpp 文件，依赖头文件。模板和宏在编译时展开。</li>
<li><strong>UE C++</strong>：UE 引入 UHT（Unreal Header Tool） 解析 UCLASS、UPROPERTY、UFUNCTION 宏，生成辅助代码.generated.h 文件。UBT(Unreal Build Tool)负责整个 UE 项目的构建管理。整个编译过程如下：</li>
</ul>
<pre><code>1. 开始：写代码
   ├── .h/.cpp 文件（包含 UCLASS / UPROPERTY / UFUNCTION 宏）
   └── .Build.cs / .Target.cs 配置模块依赖

2. 调用 Unreal Build Tool (UBT)
   ├── 解析 .uproject、.Build.cs、.Target.cs
   ├── 计算模块依赖
   └── 判断哪些模块需要编译

3. 调用 Unreal Header Tool (UHT)
   ├── 扫描所有头文件
   ├── 解析 UCLASS / USTRUCT / UPROPERTY / UFUNCTION
   └── 生成 .generated.h 文件（反射、GC、蓝图注册）

4. 回到 UBT
   ├── 收集 .cpp + 生成的 .generated.h
   ├── 调用编译器（MSVC / Clang / LLVM）
   └── 编译生成模块对象文件 (.obj)

5. 链接阶段
   ├── 按模块依赖顺序链接各个 .obj
   └── 生成最终二进制：
        - 编辑器：.dll
        - 游戏可执行：.exe / 目标平台二进制      

6. 完成
   └── 可运行的游戏或模块加载到 UE 编辑器
</code></pre>
<h3 id="25蓝图与可视化支持"><a class="header" href="#25蓝图与可视化支持">2.5蓝图与可视化支持</a></h3>
<ul>
<li>普通 C++：无法直接被可视化工具访问。</li>
<li>UE C++：可通过 BlueprintCallable、BlueprintReadWrite 等宏让 C++ 类和函数暴露给蓝图。可视化编辑器和 C++ 无缝结合，大幅提升开发效率。</li>
</ul>
<h3 id="26事件委托和回调"><a class="header" href="#26事件委托和回调">2.6事件、委托和回调</a></h3>
<ul>
<li>普通 C++：通过函数指针、std::function、虚函数实现回调。</li>
<li>UE C++：提供 Delegate、MulticastDelegate、Event，封装函数指针和对象绑定。支持动态绑定、蓝图可调用。</li>
</ul>
<h2 id="3关于裸指针-t"><a class="header" href="#3关于裸指针-t">3.关于裸指针 T*</a></h2>
<p>指针本质就是：记录一个对象在内存中的地址。当你想操作某个对象时，持有它的指针就能直接访问它，而不是重新创建一个副本。T*（原始指针）：直接指向对象内存，不参与垃圾回收，也不能自动保存/加载（不可序列化），容易悬空。引用的对象销毁时不会自动清理指针。
举个例子：</p>
<pre><code class="language-C++">APlayerController* PC = GetWorld()-&gt;GetFirstPlayerController();
</code></pre>
<p>这里我们并没有“新建”一个 PlayerController，而是找到了当前世界里已有的对象，并保存了它的内存地址到 PC。之后我们就可以通过 PC 调用它的函数或访问变量。在使用指针前，需要检查指针是不是 nullptr。例如，我们使用 controller 设置游戏的输入模式。</p>
<pre><code class="language-C++">if (PC)
{
    PC-&gt;SetInputMode(FInputModeGameAndUI());
}
</code></pre>
<p>例如，我们在一个 Character 子类 HeroCharacter.h 和 HeroCharacter.cpp 中，添加 CameraComponent，使用下面的方法，创建 CameraComponent 实例。Character 会负责子组件的生命周期。</p>
<pre><code class="language-C++">//HeroCharacter.h

UPROPERTY(VisibleAnywhere)
UCameraComponent* CameraComp;

//HeroCharacter.cpp

CameraComp = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(「CameraComp」));
CameraComp-&gt;SetupAttachment(RootComponent);
</code></pre>
<h2 id="4关于-tobjectptr"><a class="header" href="#4关于-tobjectptr">4.关于 TObjectPtr</a></h2>
<p>在虚幻 5 以后，推荐使用 TObjectPtr 替换*,上面的可以写成下面的方式</p>
<pre><code class="language-C++">UPROPERTY(VisibleAnywhere)
TObjectPtr&lt;UCameraComponent&gt; CameraComp;
</code></pre>
<p><code>TObjectPtr&lt;T&gt;</code>：轻量级智能指针，参与 GC 垃圾回收，指向对象被销毁时自动置空，可序列化，适合 UPROPERTY 成员使用。</p>
<p>建议：在 UE5 中，凡是 UObject 成员且需要序列化、编辑器操作或 GC 管理，都推荐使用<code>TObjectPtr&lt;T&gt;</code>，几乎是裸指针的安全升级版。</p>
<h2 id="5软引用-tsoftobjectptr"><a class="header" href="#5软引用-tsoftobjectptr">5.软引用 TSoftObjectPtr</a></h2>
<p>在 Unreal Engine 5 中，TSoftObjectPtr（软引用）是一种存储资产路径而非直接指向对象的指针。适合大型资源、插件化资产或延迟加载资源，能够节省内存和加快启动速度。具有延迟加载，节约内存，运行时显式加载。例如：</p>
<pre><code>UPROPERTY(EditAnywhere)
TSoftObjectPtr&lt;UMaterial&gt; WeaponMaterial; // 保存路径而不占内存

void ApplyMaterial()
{
    if (WeaponMaterial.IsValid())
    {
        MyMesh-&gt;SetMaterial(0, WeaponMaterial.LoadSynchronous()); // 显式加载
    }
}
</code></pre>
<h2 id="6弱引用-tweakobjectptr"><a class="header" href="#6弱引用-tweakobjectptr">6.弱引用 TWeakObjectPtr</a></h2>
<p>弱引用不会阻止 GC 回收对象，对象被销毁后，指针自动失效，不会悬空。访问前需要进行 IsValid()检查。比如，标记最近攻击敌人,敌人有可能被击杀。当敌人被销毁后，指针自动失效，避免悬空，不阻止 GC 回收。</p>
<pre><code class="language-C++">TWeakObjectPtr&lt;AActor&gt; LastHitEnemy = EnemyA;
if(LastHitEnemy.IsValid())
{
    LastHitEnemy-&gt;Destory();
}
</code></pre>
<h2 id="7访问运算符和-"><a class="header" href="#7访问运算符和-">7.访问运算符「.」和「-&gt;」</a></h2>
<p>平时使用，通过编码 IDE 自动提示即可。</p>
<ul>
<li>「.」访问对象的实例成员，结构体类型使用。比如，FVector, FRotator,FTransform,FHitResult, FColor</li>
<li>「-&gt;」访问指针所指对象的成员。比如，UObject, AActor,UActorComponent</li>
</ul>
<h2 id="8-静态函数"><a class="header" href="#8-静态函数">8. 静态函数</a></h2>
<p>静态函数特点是属于类本身，不依赖对象实例。调用时，不需要创建对象。内存只会保存一份，不会随着实例复制。静态函数经常用于：工具函数、蓝图函数库，全局工厂方法。</p>
<p>比如，UGameplayStatics 在 Unreal Engine C++ 里几乎是最常用的工具类之一，很多初学者和老手都会用到它。它其实就是一大堆 静态函数 的集合，主要用于方便获取游戏世界中的常用信息和执行通用操作。</p>
<pre><code class="language-C++">// 获得玩家控制器
APlayerController* PC = UGameplayStatics::GetPlayerController(this, 0);
// 获得 Pawn
APawn* Pawn = UGameplayStatics::GetPlayerPawn(this, 0);
// 查询 Actors
TArray&lt;AActor*&gt; FoundActors;
UGameplayStatics::GetAllActorsOfClass(GetWorld(), AMyEnemy::StaticClass(), FoundActors);
// 播放声音
UGameplayStatics::PlaySoundAtLocation(this, ExplosionSound, GetActorLocation());
// 播放特效
UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ExplosionFX, GetActorLocation());
// 应用伤害
UGameplayStatics::ApplyDamage(TargetActor, 50.f, GetController(), this, UDamageType::StaticClass());
// 切换关卡
UGameplayStatics::OpenLevel(this, FName(「MainMenu」));
</code></pre>
<h2 id="9-引用地址运算符函数指针"><a class="header" href="#9-引用地址运算符函数指针">9. 引用、地址运算符、函数指针</a></h2>
<p>&amp;在 UE C++中的用法与 C++类似，主要包括下面几种：</p>
<h3 id="91引用reference"><a class="header" href="#91引用reference">9.1引用（Reference）</a></h3>
<p>给变量起别名，操作引用等于操作原变量。避免大对象拷贝（如 FVector、FTransform）。用于函数参数传递，避免复制，提高性能。</p>
<pre><code class="language-C++">// 引用版本
void ModifyVector(FVector&amp; Vec)
{
    Vec.X += 1.0f;
    Vec.Y += 1.0f;
}

// 引用版本 调用
FVector MyVec(0,0,0);
ModifyVector(MyVec);  // 直接传变量
</code></pre>
<h3 id="92地址运算符"><a class="header" href="#92地址运算符">9.2地址运算符</a></h3>
<p>获取变量在内存中的地址，返回指针。</p>
<pre><code class="language-C++">// 指针版本
void ModifyVector(FVector* Vec)
{
    if(Vec)
    {
        Vec-&gt;X += 1.0f;
        Vec-&gt;Y += 1.0f;
    }
}

// 指针版本调用
FVector MyVec(1,2,3);
ModifyVector(&amp;MyVec); //传入地址
</code></pre>
<p>引用版本的 ModifyVector 函数，调用语法简单，保证不为 null,不需要解引用。</p>
<p>指针版本的 ModifyVector 函数，需要取地址 &amp;MyVec，函数内部要检查是否为 nullptr，可以传入动态分配指针或空指针，函数内部通过检查保证安全。</p>
<p>UE C++ 常用推荐：</p>
<ul>
<li>普通 struct（FVector、FTransform、FQuat 等），引用（Reference）优先。原因：语法简洁、安全、无需检查 null。内部仍然修改原对象</li>
<li>对于 UObject / Actor / Component，指针传递，可以为空，函数需检查指针有效性。</li>
</ul>
<h3 id="93函数指针"><a class="header" href="#93函数指针">9.3函数指针</a></h3>
<p>函数指针就是一个变量，它 保存函数的地址，可以通过它调用函数。在 UE C++ 中，函数指针常用于 Delegate、<em>回调</em>、绑定函数 等场景。下面是一个成员函数绑定 Delegate 的例子。参考的代码片段如下：</p>
<pre><code class="language-C++">// 创建 Actor 实例
AMyActor* MyActor = World-&gt;SpawnActor&lt;AMyActor&gt;();

// 声明 Delegate 类型
DECLARE_DELEGATE(FMyDelegate);

// 声明 Delegate
FMyDelegate Delegate;

// 绑定成员函数：对象 + 成员函数指针
Delegate.BindUObject(MyActor, &amp;AMyActor::PrintActorName);

// 执行 Delegate
if (Delegate.IsBound())
{
    Delegate.Execute();
}
</code></pre>
<h2 id="10关于前向声明"><a class="header" href="#10关于前向声明">10.关于前向声明</a></h2>
<p>在 Unreal Engine C++ 开发中，前向声明就是在文件中 提前声明一个类、结构体或枚举的名字，而不包含其完整定义。前向声明是提升编译效率、减少头文件依赖、避免循环引用的重要手段。</p>
<h3 id="101-前向声明的使用场景"><a class="header" href="#101-前向声明的使用场景">10.1 前向声明的使用场景：</a></h3>
<ul>
<li>成员指针和引用类型</li>
</ul>
<p>如果类成员是指针或引用，可以只做前向声明，不需要包含完整头文件。常见 UObject, Component, Actor 等。</p>
<pre><code class="language-C++">class UStaticMeshComponent; // 前向声明

class AMyActor : public AActor
{
    GENERATED_BODY()

private:
    UStaticMeshComponent* MeshComp; // 指针可以使用前向声明
};
</code></pre>
<ul>
<li>函数参数、返回值为指针或引用</li>
</ul>
<p>函数声明时，如果参数或返回值是指针或引用，也可以使用前向声明。如果返回值或参数是对象本身（非指针/引用），必须包含完整头文件。</p>
<pre><code class="language-C++">class AMyActor;

AMyActor* SpawnActor();       // 返回值为指针
void ProcessActor(AMyActor* Actor); // 参数为指针
</code></pre>
<h3 id="102-不可以使用前向声明的情况"><a class="header" href="#102-不可以使用前向声明的情况">10.2 不可以使用前向声明的情况</a></h3>
<pre><code class="language-C++">// class AMyActor; 
// 1. 不能是对象成员（值类型）
class UMyComponent
{
    AMyActor Actor; // 前向声明不能用，编译器需要知道大小
};

// 2. 不能是继承
class AMyChild : public AMyActor // 需要完整定义
{};

// 3. 访问成员函数或变量, 无法前向声明
AMyActor* Actor;
Actor-&gt;SetActorLocation(...); // 不能访问成员，编译器不知道内容
</code></pre>
<h2 id="11强制转换cast"><a class="header" href="#11强制转换cast">11.强制转换Cast</a></h2>
<p>在 Unreal Engine C++ 开发中，Cast 是最常用的类型安全强制转换方式，它用于在 UObject、Actor、Component 等类层级中进行类型转换，同时保证安全性。</p>
<p><strong>Cast</strong>是 UE 提供的模板函数，用于将父类指针或 UObject 指针转换为子类类型。如果转换成功，返回目标类型指针；失败返回 nullptr。例如：</p>
<pre><code class="language-C++">AActor* SomeActor = ...;
AMyCharacter* MyChar = Cast&lt;AMyCharacter&gt;(SomeActor);
​
if (MyChar)
{
    MyChar-&gt;DoSomething(); // 成功转换后可以安全调用
}
</code></pre>
<p>Cast 使用的注意事项:</p>
<ul>
<li>检查失败情况：Cast 只有在对象真的是目标类型或子类时才会成功。UE C++ 中失败返回 nullptr，蓝图里走 Cast Failed 分支，必须做判空/分支处理。</li>
<li>避免滥用：过多依赖 Cast 会让蓝图或 C++ 紧耦合，维护困难。推荐用接口、事件分发器或更明确的变量类型来减少 Cast。</li>
<li>关注性能：单次 Cast 开销不大，但高频调用（如 Tick 或循环）中频繁使用会拖慢性能。建议 缓存 Cast 结果，避免重复转换。</li>
</ul>
<h2 id="12接口用法"><a class="header" href="#12接口用法">12.接口用法</a></h2>
<p>在UE中，Interfaces是一种有效的设计，多个类可以通过接口添加函数。比如，玩家可以通过接口与关卡内的不同Actor进行交互，每个Actor都有不同的反应。在UE C++中定义的接口，既可以在C++类里实现，也可以在蓝图类里实现。</p>
<h3 id="121-声明c接口"><a class="header" href="#121-声明c接口">12.1 声明C++接口</a></h3>
<p>继承Uinterface定义一个接口，由于UE的约定，需要写两个类：UDoSomeThings和IDoSomeThings。<br>U前缀：UInterface继承UObject，用于反射系统。<br>I前缀：IDoSomeThings是接口类，存放自定义的函数。</p>
<pre><code class="language-C++">#include "CoreMinimal.h"
#include "DoSomeThings.generated.h"
​
UINTERFACE(MinimalAPI)
class UDoSomeThings : public UInterface
{
    GENERATED_BODY()
    // 这里就是空的
}
​
class YOURPROJECT_API IDoSomeThings
{
    GENERATED_BODY()
public:    
    // 这里写接口方法
}
</code></pre>
<h3 id="122-添加实现方法"><a class="header" href="#122-添加实现方法">12.2 添加实现方法</a></h3>
<p>在接口中，用两种方式添加两个接口方法。</p>
<pre><code class="language-C++">class YOURPROJECT_API IDoSomeThings
{
    GENERATED_BODY()
public:    
    // 1. C++接口方法
    virtual void DoSomeThing() = 0;  // 必须virtual 
    
    // 2. UFUNCTION接口方法
    UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category="Things")
    int GetNumberOfThings();
};
</code></pre>
<ul>
<li>C++接口方法：必须在子类的C++中实现，不支持蓝图。比如,Gas系统的这个接口，也是C++接口。</li>
</ul>
<pre><code class="language-C++">virtual UAbilitySystemComponent* GetAbilitySystemComponent() const = 0;
</code></pre>
<ul>
<li>UFUNCTION接口方法：使用BlueprintNativeEvent宏修饰符时，在C++中可选实现。如果实现需要在_Implementation中实现逻辑。支持在蓝图中可以重写。如果使用BlueprintImplementableEvent，在C++中不能实现，必须要在蓝图中实现。所以，一般大家都使用BlueprintNativeEvent。</li>
</ul>
<p>UFUNCTION的接口方法，不需要写virtual, 主要是因为UFUNCTION()和GENERATED_BODY() 宏 会生成必要的虚函数声明。</p>
<h3 id="123-c中实现接口"><a class="header" href="#123-c中实现接口">12.3 C++中实现接口</a></h3>
<p>继承接口，在cpp中写函数实现。</p>
<pre><code class="language-C++">#include "CoreMinimal.h"
#include "DoSomeThings.h"
#include "SomeThingsActor.generated.h"
​
UCLASS(Blueprintable)
class YOURPROJECT_API ASomeThingsActor : public AActor, public IDoSomeThings
{
    GENERATED_BODY()
public:    
    virtual void DoSomeThing() override;
    virtual int GetNumberOfThings_Implementation() override;
};
#include "SomeThingsActor.h"
​
void ASomeThingsActor::DoSomeThing()
{
    //....
}
​
int ASomeThingsActor::GetNumberOfThings_Implementation()
{
    return 1;
}
</code></pre>
<h3 id="124-在蓝图中实现接口"><a class="header" href="#124-在蓝图中实现接口">12.4 在蓝图中实现接口</a></h3>
<p>可以在蓝图的Class Settings中添加刚才C++定义的接口。点击Implemented Interfaces中Add, 选择DoSomeThings。在Interfaces中，可以看到接口函数的定义。</p>
<p><img src="gameDevelopment/UEC++/images/blueInterfaceParameters.png" alt=""></p>
<h2 id="125-在c和蓝图中调用"><a class="header" href="#125-在c和蓝图中调用">12.5 在C++和蓝图中调用</a></h2>
<p>在C++中调用接口，如果是C++实现的接口，可以直接使用<code>Cast&lt;IDoSomeThings&gt;</code>，例如</p>
<pre><code class="language-C++">auto I = Cast&lt;IDoSomeThings&gt;(Actor);
if (I)
{
    int Num = I-&gt;GetNumberOfThings();
}
</code></pre>
<p>如果想在C++中，调用蓝图实现的接口方法，Cast&lt;&gt;方法会返回I = nullptr,因为C++不知道蓝图。可以使用反射系统检测蓝图的接口是否可用。检测的几种方法如下：</p>
<pre><code class="language-C++">// 1. Implements
if (Actor &amp;&amp; Actor-&gt;Implements&lt;UDoSomeThings&gt;())
{
    // Use the interface
}
// 2. DoesImplementInterface 
if (UKismetSystemLibrary::DoesImplementInterface(Actor, UDoSomeThings::StaticClass())
{
    // use the interface
}
// 3. ImplementsInterface
if (Actor &amp;&amp; Actor-&gt;GetClass()-&gt;ImplementsInterface(UDoSomeThings::StaticClass()))
{
    // use the interface    
} 
</code></pre>
<p>检测到定义的接口函数，需要通过Interface wrapper调用接口，如下：</p>
<pre><code class="language-C++">if (Actor &amp;&amp; Actor-&gt;Implements&lt;UDoSomeThings&gt;())
{
    int Num = IDoSomeThings::Execute_GetNumberOfThings(Actor);
}
</code></pre>
<p>在蓝图中调用，先判断，再调用接口函数。</p>
<p><img src="gameDevelopment/UEC++/images/useInterface.png" alt=""></p>
<h3 id="126-接口定义成变量"><a class="header" href="#126-接口定义成变量">12.6 接口定义成变量</a></h3>
<p>如果想把接口像Class类型一样，保存成变量，需要在UE C++中使用（Blueprintable）宏修饰符。</p>
<pre><code class="language-C++">UINTERFACE(Blueprintable)
class UDoSomeThings : public UInterface
{
    GENERATED_BODY()
};
</code></pre>
<p>在蓝图中，可以直接创建DoSomething类型的Interface变量IDo。如果把一个Actor类型变量保存成接口变量IDo，需要先Cast to DoSomeThings接口后，设定IDo变量。</p>
<p><img src="gameDevelopment/UEC++/images/castInterface.png" alt=""></p>
<p>在C++中，需要创建接口变量需要使用TScriptInterface</p>
<pre><code class="language-C++">UPROPERTY(BlueprintReadWrite)
TScriptInterface&lt;IDoSomeThings&gt; SomethingInstance;
</code></pre>
<p>使用这个变量前可以判断是否为空，如果接口实现是在C++完成，可以直接使用。</p>
<pre><code class="language-C++">int Num;
if (SomethingInstance)
{
    Num = SomethingInstance-&gt;GetNumberOfThings();
}
</code></pre>
<p>把实现接口的对象赋值给接口变量的方法如下，直接赋值</p>
<pre><code class="language-C++">if (UKismetSystemLibrary::DoesImplementInterface(Actor, UDoSomeThings::StaticClass()))
{
    SomethingInstance = Actor;
}
</code></pre>
<p>如果接口的实现是在蓝图中，需要使用</p>
<pre><code class="language-C++">int Num = IDoSomeThings::Execute_GetNumberOfThings(SomethingInstance.GetObject());
</code></pre>
<p>使用UOBject类型变量，来直接执行接口也是一种方法。</p>
<pre><code class="language-C++">UPROPERTY(BlueprintReadWrite)
UObject* SomethingInstance;
​
if (SomethingInstance)
{
    int Num = IDoSomeThings::Execute_GetNumberOfThings(SomethingInstance);
}
</code></pre>
<h2 id="13委托用法"><a class="header" href="#13委托用法">13.委托用法</a></h2>
<p>UE官方常见委托分类方式：单播，多播和动态。委托是一种常见的回调机制，让一个对象可以把事件通知到另一个对象，解耦逻辑。比如：角色受到伤害，通知UI，更新血条。</p>
<h3 id="131-单播委托"><a class="header" href="#131-单播委托">13.1 单播委托</a></h3>
<p>Single cast delegate，只能绑定一个函数，没有反射，性能最好。只能在C++中使用，蓝图看不到。适合在“1对1”的通知，比如：一个异步任务完成，通知唯一的回调函数。</p>
<p><strong>无参单播委托</strong></p>
<pre><code class="language-C++">// 声明一个无参的单播委托
DECLARE_DELEGATE(FOnFinished);
​
// 使用
FOnFinished OnFinished;
// 绑定
OnFinished.BindUObject(this, &amp;AMyActor::HandleFinished);
​
// 定义函数
void AMyActor::HandleFinished()
{
    UE_LOG(LogTemp, Log, TEXT("Task Finished!"));
}
​
// 调用
if (OnFinished.IsBound())
{
    OnFinished.Execute();  
    // 或者更安全：
    // OnFinished.ExecuteIfBound();
}
</code></pre>
<p><strong>带参数/返回值的单播委托</strong></p>
<pre><code class="language-C++">// 声明一个带参数的单播委托
DECLARE_DELEGATE_OneParam(FOnDamaged, float);
​
// 使用
FOnDamaged OnDamaged;
​
// 绑定
OnDamaged.BindUObject(this, &amp;AMyActor::HandleDamaged);
​
// 定义函数
void AMyActor::HandleDamaged(float Damage)
{
    UE_LOG(LogTemp, Log, TEXT("Actor took %f damage!"), Damage);
}
​
// 调用
if (OnDamaged.IsBound())
{
    OnDamaged.Execute(25.f);  // 传递参数
}
</code></pre>
<p>带返回值的代理，只需要在宏定义时，使用带有“RetVal”关键字的宏，例如，在执行后获得返回值。其他使用过程类似。</p>
<pre><code class="language-C++">// 声明
DECLARE_DELEGATE_RetVal(int32, OnDamaged);
// 返回值
int32 Result = OnDamaged.Execute();
</code></pre>
<h3 id="132-多播委托"><a class="header" href="#132-多播委托">13.2 多播委托</a></h3>
<p>可以绑定多个函数，一个事件触发时，所有绑定都会被调用。性能依然很好。同样主要用于C++,蓝图不可见。</p>
<pre><code class="language-C++">// 声明
DECLARE_MULTICAST_DELEGATE(FOnDead);
​
// 使用
FOnDead OnDead;
OnDead.AddUObject(this, &amp;AMyActor::HandleDeath);
OnDead.AddLambda([](){ UE_LOG(LogTemp, Log, TEXT("Lambda called!")); });
​
// 触发
OnDead.Broadcast();
</code></pre>
<h3 id="133-动态单播"><a class="header" href="#133-动态单播">13.3 动态单播</a></h3>
<p>支持反射，可以暴露给蓝图。可以是单播，也可以是多播。有一定性能开销。
动态单播，一个委托绑定一个函数。如果绑定多个，后面的会覆盖前一个。</p>
<pre><code class="language-C++">// 声明一个动态单播委托（无参数）
DECLARE_DYNAMIC_DELEGATE(FSimpleDynamicDelegate);
​
// 声明一个动态单播委托（带参数）
DECLARE_DYNAMIC_DELEGATE_OneParam(FOnHealthChanged, float, NewHealth);
UCLASS()
class AMyActor : public AActor
{
    GENERATED_BODY()
public:
    // 定义成员变量
    FSimpleDynamicDelegate OnSimpleEvent;
    FOnHealthChanged OnHealthChanged;
​
    void TriggerEvent()
    {
        // 调用无参委托
        OnSimpleEvent.ExecuteIfBound();
        // 调用有参委托
        OnHealthChanged.ExecuteIfBound(75.0f);
    }
};
</code></pre>
<p>绑定</p>
<pre><code class="language-C++">// 在另一个类或蓝图中绑定
MyActor-&gt;OnSimpleEvent.BindDynamic(this, &amp;UMyComponent::HandleSimple);
MyActor-&gt;OnHealthChanged.BindDynamic(this, &amp;UMyComponent::HandleHealth);
​
// 回调函数格式必须是 UFUNCTION
UFUNCTION()
void HandleSimple() { UE_LOG(LogTemp, Warning, TEXT("Simple event triggered!")); }
​
UFUNCTION()
void HandleHealth(float Value) { UE_LOG(LogTemp, Warning, TEXT("Health: %f"), Value); }
</code></pre>
<h3 id="134-动态多播"><a class="header" href="#134-动态多播">13.4 动态多播</a></h3>
<p>动态多播，一个委托可以绑定多个函数。触发时会顺序调用所有绑定的回调。声明如下：</p>
<pre><code class="language-C++">// 无参数
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FSimpleMulticastDelegate);
​
// 带参数
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnScoreChanged, int32, NewScore);

</code></pre>
<p>像下面的方法进行使用：</p>
<pre><code class="language-C++">UCLASS()
class AMyActor : public AActor
{
    GENERATED_BODY()
​
public:
    // 使用 UPROPERTY，支持蓝图绑定
    UPROPERTY(BlueprintAssignable)
    FSimpleMulticastDelegate OnSimpleEvent;
​
    UPROPERTY(BlueprintAssignable)
    FOnScoreChanged OnScoreChanged;
​
    void TriggerEvent()
    {
        // 触发多播委托（依次调用所有绑定函数）
        OnSimpleEvent.Broadcast();
        OnScoreChanged.Broadcast(100);
    }
    
    UFUNCTION()
    void HandleSimple() { UE_LOG(LogTemp, Warning, TEXT("Multicast simple event!")); }
​
    UFUNCTION()
    void HandleScore(int32 Score) { UE_LOG(LogTemp, Warning, TEXT("Score: %d"), Score); }
};
</code></pre>
<p><strong>动态多播绑定</strong></p>
<pre><code class="language-C++">// C++绑定
MyActor-&gt;OnSimpleEvent.AddDynamic(this, &amp;UMyComponent::HandleSimple);
MyActor-&gt;OnScoreChanged.AddDynamic(this, &amp;UMyComponent::HandleScore);
​
// C++解绑
MyActor-&gt;OnScoreChanged.RemoveDynamic(this, &amp;UMyComponent::HandleScore);
​
// 蓝图绑定
// 因为用 UPROPERTY(BlueprintAssignable)，蓝图里可以直接拖节点绑定
</code></pre>
<p>下面是蓝图中的动态绑定
<img src="gameDevelopment/UEC++/images/bindEvent.png" alt=""></p>
<h3 id="135-委托总结"><a class="header" href="#135-委托总结">13.5 委托总结</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th></th><th>常见定义宏</th><th>绑定方式</th><th>支持蓝图</th><th>绑定函数个数</th></tr>
</thead>
<tbody>
<tr><td>单播</td><td><code>DECLARE_DELEGATE</code></td><td><code>Delegate.BindUObject(this, &amp;Class::Func)</code></td><td>X</td><td>1</td></tr>
<tr><td>多播</td><td><code>DECLARE_MULTICAST_DELEGATE</code></td><td><code>Delegate.AddUObject(this, &amp;Class::Func)</code></td><td>X</td><td>多个</td></tr>
<tr><td>动态单播</td><td><code>DECLARE_DYNAMIC_DELEGATE</code></td><td><code>Delegate.BindDynamic(this, &amp;Class::Func)</code></td><td>V</td><td>1</td></tr>
<tr><td>动态多播</td><td><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE</code></td><td><code>Delegate.AddDynamic(this, &amp;Class::Func)</code></td><td>V</td><td>多个</td></tr>
</tbody>
</table>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
